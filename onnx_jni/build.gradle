plugins {
    id "java"
    id "com.diffplug.spotless" version "6.24.0"
    id "edu.wpi.first.WpilibTools" version "1.3.0"
    id "edu.wpi.first.wpilib.repositories.WPILibRepositoriesPlugin" version "2020.2"
}

apply from: "${rootDir}/versioningHelper.gradle"

repositories {
    mavenCentral()
    maven {
        url = "https://frcmaven.wpi.edu/artifactory/release"
    }
}

wpilibRepositories.addAllReleaseRepositories(project)
wpilibRepositories.addAllDevelopmentRepositories(project)

ext {
    onnxOpenCvVersion = "4.10.0-3"
    onnxFrcYear = "frc2025"
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
    withSourcesJar()
}

dependencies {
    implementation wpilibTools.deps.wpilibOpenCvJava(onnxFrcYear, onnxOpenCvVersion)
}

tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}

tasks.withType(Javadoc) {
    options.encoding = "UTF-8"
}

def nativeFolderName = {
    def os = org.gradle.internal.os.OperatingSystem.current()
    def arch = System.getProperty("os.arch").toLowerCase()

    if (os.isWindows()) {
        return "winx64"
    }

    if (os.isMacOsX()) {
        return "osxuniversal"
    }

    if (os.isLinux()) {
        if (arch.contains("aarch64") || arch.contains("arm64")) {
            return "linuxarm64"
        }
        if (arch.contains("arm")) {
            return "linuxarm32"
        }
        return "linuxx64"
    }

    return "unknown"
}

ext.nativeLibFolder = nativeFolderName()
ext.outputsFolder = file("${buildDir}/outputs")

def cmakeOutputRoots = [
    file("${projectDir}/cmake_build/install/lib"),
    file("${projectDir}/cmake_build/install/bin"),
    file("${projectDir}/cmake_build/lib"),
    file("${projectDir}/cmake_build/bin")
]

tasks.register("prepareNativeResources", Sync) {
    def existingRoots = cmakeOutputRoots.findAll { it.exists() }
    onlyIf { !existingRoots.isEmpty() }
    existingRoots.each { root ->
        from(root) {
            include "**/*.so", "**/*.dylib", "**/*.dll"
            eachFile { fileCopyDetails ->
                fileCopyDetails.path = "nativelibraries/${nativeLibFolder}/${fileCopyDetails.name}"
            }
        }
    }
    into("${buildDir}/generated/native-resources")
}

// Ensure native binaries are packed into the resulting JAR when available
tasks.named("processResources") {
    dependsOn("prepareNativeResources")
    from("${buildDir}/generated/native-resources") {
        include "**/*"
    }
}

spotless {
    java {
        target fileTree('.') {
            include '**/*.java'
            exclude '**/build/**', '**/build-*/**', '**/src/generated/**'
        }
        toggleOffOn()
        googleJavaFormat()
        indentWithTabs(2)
        indentWithSpaces(4)
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
    groovyGradle {
        target fileTree('.') {
            include '**/*.gradle'
            exclude '**/build/**', '**/build-*/**'
        }
        greclipse()
        indentWithSpaces(4)
        trimTrailingWhitespace()
        endWithNewline()
    }
    format 'misc', {
        target fileTree('.') {
            include '**/*.md', '**/.gitignore'
            exclude '**/build/**', '**/build-*/**'
        }
        trimTrailingWhitespace()
        indentWithSpaces(2)
        endWithNewline()
    }
}

configurations {
    nativeRuntime
}

tasks.register('nativeLibraryJar', Jar) {
    dependsOn "build"
    archiveClassifier = nativeLibFolder
    from("${buildDir}/generated/native-resources")
}

tasks.register('copyNativeLibrary', Sync) {
    dependsOn "prepareNativeResources"
    from("${buildDir}/generated/native-resources")
    into outputsFolder
}

tasks.named("build") {
    dependsOn "prepareNativeResources"
}
